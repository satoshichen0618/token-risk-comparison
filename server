// åç«¯APIä»£ç†æœåŠ¡å™¨
// ä½¿ç”¨æ–¹æ³•ï¼šnpm install express cors axios cheerio
// ç„¶åè¿è¡Œï¼šnode server.js

const express = require('express');
const cors = require('cors');
const axios = require('axios');
const cheerio = require('cheerio');

const app = express();
app.use(cors());
app.use(express.json());

// é“¾æ˜ å°„
const chainMap = {
    'ETH': 'eth',
    'BSC': 'bsc',
    'SOL': 'sol',
    'BASE': 'base',
    'XLayer': 'xlayer',
    'ARB': 'arb',
    'OP': 'op',
    'POLYGON': 'polygon'
};

// GMGN APIç«¯ç‚¹
app.get('/api/gmgn', async (req, res) => {
    try {
        const { address, chain } = req.query;
        const chainId = chainMap[chain] || 'eth';
        
        // è®¿é—®GMGNé¡µé¢
        const url = `https://gmgn.ai/token/${chainId}/${address}`;
        console.log(`Fetching GMGN: ${url}`);
        
        const response = await axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            timeout: 10000
        });
        
        const $ = cheerio.load(response.data);
        
        // è§£ææ•°æ®ï¼ˆéœ€è¦æ ¹æ®å®é™…é¡µé¢ç»“æ„è°ƒæ•´é€‰æ‹©å™¨ï¼‰
        // è¿™é‡Œæä¾›ç¤ºä¾‹ç»“æ„ï¼Œå®é™…éœ€è¦æ ¹æ®GMGNé¡µé¢è°ƒæ•´
        let riskScore = 0;
        let isHoneypot = false;
        
        // å°è¯•å¤šç§å¯èƒ½çš„é€‰æ‹©å™¨
        const riskScoreText = $('.risk-score, [data-risk-score], .score').first().text();
        if (riskScoreText) {
            const match = riskScoreText.match(/(\d+)/);
            if (match) riskScore = parseInt(match[1]);
        }
        
        const honeypotText = $('.honeypot, [data-honeypot]').first().text().toLowerCase();
        isHoneypot = honeypotText.includes('yes') || honeypotText.includes('æ˜¯');
        
        res.json({
            honeypot: isHoneypot ? 'Yes' : 'No',
            riskScore: riskScore || Math.floor(Math.random() * 100), // å¦‚æœæ— æ³•è§£æï¼Œè¿”å›éšæœºå€¼ä½œä¸ºç¤ºä¾‹
            sellable: isHoneypot ? 'No' : 'Yes',
            liquidity: riskScore > 60 ? 'Low' : riskScore > 30 ? 'Medium' : 'High',
            trading: riskScore > 70 ? 'å¼‚å¸¸' : 'æ­£å¸¸'
        });
    } catch (error) {
        console.error('GMGN API Error:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// Ave.ai APIç«¯ç‚¹
app.get('/api/ave', async (req, res) => {
    try {
        const { address, chain } = req.query;
        const chainId = chainMap[chain] || 'ethereum';
        
        const url = `https://ave.ai/token/${chainId}/${address}`;
        console.log(`Fetching Ave: ${url}`);
        
        const response = await axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            timeout: 10000
        });
        
        const $ = cheerio.load(response.data);
        
        // è§£ææ•°æ®ï¼ˆéœ€è¦æ ¹æ®å®é™…é¡µé¢è°ƒæ•´ï¼‰
        let riskLevel = 'B';
        const riskLevelText = $('.risk-level, [data-risk-level]').first().text().toUpperCase();
        if (riskLevelText.match(/[ABCD]/)) {
            riskLevel = riskLevelText.match(/[ABCD]/)[0];
        }
        
        res.json({
            riskLevel: riskLevel,
            scam: riskLevel === 'D' || riskLevel === 'C' ? 'Yes' : 'No',
            audited: riskLevel === 'A' ? 'Yes' : 'No',
            concentration: riskLevel === 'A' ? 'ä½' : riskLevel === 'B' ? 'ä¸­' : 'é«˜'
        });
    } catch (error) {
        console.error('Ave API Error:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// CMC APIç«¯ç‚¹
app.get('/api/cmc', async (req, res) => {
    try {
        const { address, chain } = req.query;
        
        // CMCé€šå¸¸é€šè¿‡ä»£å¸åç§°è®¿é—®ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
        const url = `https://coinmarketcap.com/currencies/${address}/`;
        console.log(`Fetching CMC: ${url}`);
        
        const response = await axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            timeout: 10000
        });
        
        const $ = cheerio.load(response.data);
        
        // æ£€æŸ¥æ˜¯å¦æ”¶å½•
        const isListed = $('h1').length > 0 && !$('h1').text().includes('404');
        
        res.json({
            listed: isListed ? 'Yes' : 'No',
            riskTag: 'No', // éœ€è¦æ ¹æ®å®é™…é¡µé¢è§£æ
            liquidity: isListed ? 'DEX + CEX' : 'ä»…DEX',
            credibility: isListed ? 85 : 30
        });
    } catch (error) {
        console.error('CMC API Error:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// Coinbase APIç«¯ç‚¹
app.get('/api/coinbase', async (req, res) => {
    try {
        const { address, chain } = req.query;
        const chainId = chainMap[chain] || 'ethereum';
        
        const url = `https://www.coinbase.com/explorer/chains/${chainId}/addresses/${address}`;
        console.log(`Fetching Coinbase: ${url}`);
        
        const response = await axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            },
            timeout: 10000
        });
        
        const $ = cheerio.load(response.data);
        
        // è§£ææ•°æ®ï¼ˆéœ€è¦æ ¹æ®å®é™…é¡µé¢è°ƒæ•´ï¼‰
        res.json({
            riskLevel: 'Low', // éœ€è¦å®é™…è§£æ
            scam: 'No',
            riskTx: '2%',
            blacklist: 'æ— åŒ¹é…'
        });
    } catch (error) {
        console.error('Coinbase API Error:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// å¥åº·æ£€æŸ¥
app.get('/api/health', (req, res) => {
    res.json({ status: 'ok', message: 'APIæœåŠ¡å™¨è¿è¡Œæ­£å¸¸' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`ğŸš€ åç«¯APIæœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:${PORT}`);
    console.log(`ğŸ“¡ APIç«¯ç‚¹: http://localhost:${PORT}/api/`);
    console.log(`ğŸ’¡ å¥åº·æ£€æŸ¥: http://localhost:${PORT}/api/health`);
});

